
public class Grammar {
//	13 장
	
//	멀티태스킹(multi tasking) : 동시에 여러 작업을 수행
//	
//	멀티 프로세스(multi process) : 프로세스가 여러개 실핼
//	
//	멀티 스레드(multi thread) : 동시에 여러 스레드가 실행 
//	>> 스레드는 프로세스의 하위(sub)단위이다.
//	>> 하나의 프로세스에 여러 스레드를 생성
//	
//	웹 서버의 멀티스레딩 사례 
//	>> 대형 웹 사이트의 경우 동시접속자 수가 굉장히 많음
//	>> 각 접속자를 멀티 스레드라고 보고 관리하는 것. 이것을 잘 하냐 못하냐로 좋고 나쁨이 결정됨
//	
//	JVM은 한개의 응용프로그램만 실행 가능하다 >> 여러개의 응용프로그램 실행 불가.
//	>> 하나의 응용프로그램에 멀티스레드를 만들어 멀티태스킹을 하는것
//	
//	스레드를 만드는 방법
//	1. Thread 클래스 이용 >> 상속이기 떄문에 굳이 오버라이딩안해도 됨.
//	2. Runnable 인터페이스 이용 >> 추상메소드이기 때문에 반드시 오버라이딩 해야함
	
//	스레드는 주로 채팅 프로그램을 짤 때 사용된다.
//	
//	스레드의 상태 6가지
//	1. NEW				: 탄생			>> new Thread();
//	2. RUNNABLE			: 준비 / 실행중	>> start();
//	3. WAITING			: 대기			>> object.wait(); 재시작 요청 > notify();
//	4. TIMED_WAITING	: 시간대기			>> sleep();
//	5. BLOCK			: 봉쇄			>> I/O작업 요청
//	6. TERMINATED		: 종료
//	
//	스레드 우선순위
//	최대값 = 10
//	최소값 = 1
//	보통값 = 5
//	
//	flag : 전쟁에서 깃발을 사용해서 돌격, 후퇴등을 알려주는데서 유래.
//	>> flag변수는 특정값(주로 boolean)을 알려주는 용도로 사용
//	
//	스레드 동기화 (Thread Synchronization) >> 동시에 하는것이 아닌 순서대로 처리
//	: 멀티스레드 프로그래ㅐㅁ 작성 시 주의점
//	>> 다수 스레드가 공유 데이터에 동시에 접근하는 경우 : 공유데이터의 값에 예상치 못한 결과 발생 가능
//	: 스레드 동기화
//	>> '공유데이터'에 대한 멀티스레드의 동시 접근 문제 해결책 : 공유 데이터를 접근하는 모든 스레드 한 줄 세우기 / 한 스레드가 공유데이터에 대한 작업을 끝낼때까지 다른스레드 대기
	
//	스레드 동기화 방법
//	1. synchronized
//	2. wait()-notify()로 조절
//	
//	synchronized void add() {
//		int n = getCurrentSum();
//		n += 10;
//		setCurrentSum(n);
//	}
	
//	wait() : 다른 스레드가 notify를 불러줄 때까지 기다린다.
//	notify() : wait()를 호출하여 대기중인 스레드를 꺠우고 RUNNABLE상태로 만든다.
//			   두개 이생의 스레드가 대기중이라도 오직 한 스레드만 깨운다.
//	notifyAll() : wait()를 호출하여 대기중인 모든 스레드를 깨우고 모두 RUNNABLE상태로 만들어준다.
	
//	14 장
	
	메뉴 만들기
	메뉴만들기에 필요한 스윙 컴포넌트
	1. JMenuBar  : 메뉴바의 기능을 하는 컴포넌트
	2. JMenu     : 파일, 편집 등 하나의 게뮤 기능을 하는 컴포넌트
	3. JMenuItem : 파일 메뉴 내에 저장 등 메뉴 아이템 컴포넌트
	4. 분리선		 : 메뉴 아이템 사이의 분리선
	
	메뉴 만드는 과정
	>> JMenuBar컴포넌트 생성
	>> JMenu 컴포넌트를 생성하여 Bar에 붙힌다
	>> JMenuItem 컴포넌트를 생성하여 Menu에 붙힌다
	>> 여러개의 메뉴와 메뉴 아이템을 생성한다.
	
	메뉴 아이템에 Action이벤트 달기
	ActionListener를 이용
	각 JMenuItem 컴포넌트에 Aciton 이벤트 리스너 설정
	
	
	
	
}
